"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/standings.ts":
/*!**************************!*\
  !*** ./lib/standings.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildSpotlightFromEntries: function() { return /* binding */ buildSpotlightFromEntries; },\n/* harmony export */   buildSummaryFromEntries: function() { return /* binding */ buildSummaryFromEntries; },\n/* harmony export */   buildUniversityMatrix: function() { return /* binding */ buildUniversityMatrix; },\n/* harmony export */   mapBackendTeamToEntry: function() { return /* binding */ mapBackendTeamToEntry; },\n/* harmony export */   normalizeBackendPayload: function() { return /* binding */ normalizeBackendPayload; },\n/* harmony export */   summarizeStreaks: function() { return /* binding */ summarizeStreaks; }\n/* harmony export */ });\nconst MAX_VISIBLE_TEAMS = 10;\nfunction normalizeBackendPayload(payload) {\n    if (!(payload === null || payload === void 0 ? void 0 : payload.success) || !payload.data) {\n        return {\n            updatedAt: new Date().toISOString(),\n            summary: buildSummaryFromEntries([]),\n            spotlight: buildSpotlightFromEntries([]),\n            entries: []\n        };\n    }\n    const entries = Object.values(payload.data).map(mapBackendTeamToEntry).sort((a, b)=>{\n        if (b.score === a.score) {\n            var _b_lastSubmission, _a_lastSubmission;\n            return ((_b_lastSubmission = b.lastSubmission) !== null && _b_lastSubmission !== void 0 ? _b_lastSubmission : \"\").localeCompare((_a_lastSubmission = a.lastSubmission) !== null && _a_lastSubmission !== void 0 ? _a_lastSubmission : \"\");\n        }\n        return b.score - a.score;\n    }).slice(0, MAX_VISIBLE_TEAMS).map((entry, index)=>({\n            ...entry,\n            rank: index + 1\n        }));\n    return {\n        updatedAt: new Date().toISOString(),\n        summary: buildSummaryFromEntries(entries),\n        spotlight: buildSpotlightFromEntries(entries),\n        entries\n    };\n}\nfunction mapBackendTeamToEntry(team) {\n    var _sortedSolves_;\n    const sortedSolves = [\n        ...team.solves\n    ].sort((a, b)=>Date.parse(b.date) - Date.parse(a.date));\n    const solved = team.solves.length;\n    var _team_bracket_name, _sortedSolves__date;\n    return {\n        rank: 0,\n        team: team.name,\n        university: (_team_bracket_name = team.bracket_name) !== null && _team_bracket_name !== void 0 ? _team_bracket_name : \"Independent\",\n        accountUrl: team.account_url,\n        score: team.score,\n        penalty: Math.max(0, solved * 5),\n        solved,\n        streak: solved,\n        lastSubmission: (_sortedSolves__date = (_sortedSolves_ = sortedSolves[0]) === null || _sortedSolves_ === void 0 ? void 0 : _sortedSolves_.date) !== null && _sortedSolves__date !== void 0 ? _sortedSolves__date : null\n    };\n}\nfunction buildSummaryFromEntries(entries) {\n    const totalSolves = entries.reduce((acc, entry)=>acc + entry.solved, 0);\n    const universities = new Set(entries.map((entry)=>entry.university)).size;\n    const solveRate = entries.length === 0 ? 0 : Math.min(100, Math.round(totalSolves / (entries.length * 10) * 100));\n    return {\n        liveParticipants: entries.length,\n        universities,\n        submissions: totalSolves,\n        solveRate: Number.isFinite(solveRate) ? solveRate : 0\n    };\n}\nfunction buildSpotlightFromEntries(entries) {\n    if (entries.length === 0) {\n        return {\n            fastestSolveTeam: \"\",\n            highlightMessage: \"Awaiting live standings...\"\n        };\n    }\n    const latestSolve = entries.reduce((latest, entry)=>{\n        if (!entry.lastSubmission) {\n            return latest;\n        }\n        if (!latest.lastSubmission) {\n            return entry;\n        }\n        return Date.parse(entry.lastSubmission) > Date.parse(latest.lastSubmission) ? entry : latest;\n    }, entries[0]);\n    return {\n        fastestSolveTeam: latestSolve.team,\n        highlightMessage: latestSolve.lastSubmission ? \"Latest solve synced at \".concat(new Date(latestSolve.lastSubmission).toLocaleTimeString()) : \"Solves streaming in...\"\n    };\n}\nfunction buildUniversityMatrix(entries) {\n    return entries.reduce((acc, entry)=>{\n        if (!acc[entry.university]) {\n            acc[entry.university] = {\n                teams: 0,\n                cumulativeScore: 0\n            };\n        }\n        acc[entry.university].teams += 1;\n        acc[entry.university].cumulativeScore += entry.score;\n        return acc;\n    }, {});\n}\nfunction summarizeStreaks(entries) {\n    return entries.reduce((acc, entry)=>{\n        if (entry.streak > acc.longest) {\n            acc.longest = entry.streak;\n            acc.team = entry.team;\n        }\n        acc.total += entry.streak;\n        return acc;\n    }, {\n        longest: 0,\n        total: 0,\n        team: \"\"\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0EsUUFBUWdDLE1BQU0sQ0FDbkIsQ0FBQ0MsS0FBS3JCO1FBQ0osSUFBSUEsTUFBTWtCLE1BQU0sR0FBR0csSUFBSW9CLE9BQU8sRUFBRTtZQUM5QnBCLElBQUlvQixPQUFPLEdBQUd6QyxNQUFNa0IsTUFBTTtZQUMxQkcsSUFBSWxCLElBQUksR0FBR0gsTUFBTUcsSUFBSTtRQUN2QjtRQUNBa0IsSUFBSXFCLEtBQUssSUFBSTFDLE1BQU1rQixNQUFNO1FBQ3pCLE9BQU9HO0lBQ1QsR0FDQTtRQUFFb0IsU0FBUztRQUFHQyxPQUFPO1FBQUd2QyxNQUFNO0lBQUc7QUFFckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3N0YW5kaW5ncy50cz9mNTRmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB0eXBlIEJhY2tlbmRTb2x2ZSA9IHtcclxuICBjaGFsbGVuZ2VfaWQ6IG51bWJlcjtcclxuICBhY2NvdW50X2lkOiBudW1iZXI7XHJcbiAgdGVhbV9pZDogbnVtYmVyO1xyXG4gIHVzZXJfaWQ6IG51bWJlcjtcclxuICB2YWx1ZTogbnVtYmVyO1xyXG4gIGRhdGU6IHN0cmluZztcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEJhY2tlbmRUZWFtID0ge1xyXG4gIGlkOiBudW1iZXI7XHJcbiAgYWNjb3VudF91cmw6IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgc2NvcmU6IG51bWJlcjtcclxuICBicmFja2V0X2lkOiBudW1iZXIgfCBudWxsO1xyXG4gIGJyYWNrZXRfbmFtZTogc3RyaW5nIHwgbnVsbDtcclxuICBzb2x2ZXM6IEJhY2tlbmRTb2x2ZVtdO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgQmFja2VuZFN0YW5kaW5nc1Jlc3BvbnNlID0ge1xyXG4gIHN1Y2Nlc3M6IGJvb2xlYW47XHJcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgQmFja2VuZFRlYW0+O1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgU3RhbmRpbmdFbnRyeSA9IHtcclxuICByYW5rOiBudW1iZXI7XHJcbiAgdGVhbTogc3RyaW5nO1xyXG4gIHVuaXZlcnNpdHk6IHN0cmluZztcclxuICBhY2NvdW50VXJsOiBzdHJpbmc7XHJcbiAgc2NvcmU6IG51bWJlcjtcclxuICBwZW5hbHR5OiBudW1iZXI7XHJcbiAgc29sdmVkOiBudW1iZXI7XHJcbiAgc3RyZWFrOiBudW1iZXI7XHJcbiAgbGFzdFN1Ym1pc3Npb246IHN0cmluZyB8IG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBTdGFuZGluZ3NQYXlsb2FkID0ge1xyXG4gIHVwZGF0ZWRBdDogc3RyaW5nO1xyXG4gIHN1bW1hcnk6IHtcclxuICAgIGxpdmVQYXJ0aWNpcGFudHM6IG51bWJlcjtcclxuICAgIHVuaXZlcnNpdGllczogbnVtYmVyO1xyXG4gICAgc3VibWlzc2lvbnM6IG51bWJlcjtcclxuICAgIHNvbHZlUmF0ZTogbnVtYmVyO1xyXG4gIH07XHJcbiAgc3BvdGxpZ2h0OiB7XHJcbiAgICBmYXN0ZXN0U29sdmVUZWFtOiBzdHJpbmc7XHJcbiAgICBoaWdobGlnaHRNZXNzYWdlOiBzdHJpbmc7XHJcbiAgfTtcclxuICBlbnRyaWVzOiBTdGFuZGluZ0VudHJ5W107XHJcbn07XHJcblxyXG5jb25zdCBNQVhfVklTSUJMRV9URUFNUyA9IDEwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUJhY2tlbmRQYXlsb2FkKHBheWxvYWQ6IEJhY2tlbmRTdGFuZGluZ3NSZXNwb25zZSk6IFN0YW5kaW5nc1BheWxvYWQge1xyXG4gIGlmICghcGF5bG9hZD8uc3VjY2VzcyB8fCAhcGF5bG9hZC5kYXRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgc3VtbWFyeTogYnVpbGRTdW1tYXJ5RnJvbUVudHJpZXMoW10pLFxyXG4gICAgICBzcG90bGlnaHQ6IGJ1aWxkU3BvdGxpZ2h0RnJvbUVudHJpZXMoW10pLFxyXG4gICAgICBlbnRyaWVzOiBbXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LnZhbHVlcyhwYXlsb2FkLmRhdGEpXHJcbiAgICAubWFwKG1hcEJhY2tlbmRUZWFtVG9FbnRyeSlcclxuICAgIC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgIGlmIChiLnNjb3JlID09PSBhLnNjb3JlKSB7XHJcbiAgICAgICAgcmV0dXJuIChiLmxhc3RTdWJtaXNzaW9uID8/IFwiXCIpLmxvY2FsZUNvbXBhcmUoYS5sYXN0U3VibWlzc2lvbiA/PyBcIlwiKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYi5zY29yZSAtIGEuc2NvcmU7XHJcbiAgICB9KVxyXG4gICAgLnNsaWNlKDAsIE1BWF9WSVNJQkxFX1RFQU1TKVxyXG4gICAgLm1hcCgoZW50cnksIGluZGV4KSA9PiAoeyAuLi5lbnRyeSwgcmFuazogaW5kZXggKyAxIH0pKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgc3VtbWFyeTogYnVpbGRTdW1tYXJ5RnJvbUVudHJpZXMoZW50cmllcyksXHJcbiAgICBzcG90bGlnaHQ6IGJ1aWxkU3BvdGxpZ2h0RnJvbUVudHJpZXMoZW50cmllcyksXHJcbiAgICBlbnRyaWVzLFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBCYWNrZW5kVGVhbVRvRW50cnkodGVhbTogQmFja2VuZFRlYW0pOiBTdGFuZGluZ0VudHJ5IHtcclxuICBjb25zdCBzb3J0ZWRTb2x2ZXMgPSBbLi4udGVhbS5zb2x2ZXNdLnNvcnQoKGEsIGIpID0+IERhdGUucGFyc2UoYi5kYXRlKSAtIERhdGUucGFyc2UoYS5kYXRlKSk7XHJcbiAgY29uc3Qgc29sdmVkID0gdGVhbS5zb2x2ZXMubGVuZ3RoO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmFuazogMCxcclxuICAgIHRlYW06IHRlYW0ubmFtZSxcclxuICAgIHVuaXZlcnNpdHk6IHRlYW0uYnJhY2tldF9uYW1lID8/IFwiSW5kZXBlbmRlbnRcIixcclxuICAgIGFjY291bnRVcmw6IHRlYW0uYWNjb3VudF91cmwsXHJcbiAgICBzY29yZTogdGVhbS5zY29yZSxcclxuICAgIHBlbmFsdHk6IE1hdGgubWF4KDAsIHNvbHZlZCAqIDUpLCAvLyBCYWNrZW5kIGRvZXMgbm90IGV4cG9zZSBwZW5hbHRpZXMsIHNvIGFwcHJveGltYXRlIHZpYSBzb2x2ZSBjb3VudC5cclxuICAgIHNvbHZlZCxcclxuICAgIHN0cmVhazogc29sdmVkLFxyXG4gICAgbGFzdFN1Ym1pc3Npb246IHNvcnRlZFNvbHZlc1swXT8uZGF0ZSA/PyBudWxsLFxyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFN1bW1hcnlGcm9tRW50cmllcyhlbnRyaWVzOiBTdGFuZGluZ0VudHJ5W10pOiBTdGFuZGluZ3NQYXlsb2FkW1wic3VtbWFyeVwiXSB7XHJcbiAgY29uc3QgdG90YWxTb2x2ZXMgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4gYWNjICsgZW50cnkuc29sdmVkLCAwKTtcclxuICBjb25zdCB1bml2ZXJzaXRpZXMgPSBuZXcgU2V0KGVudHJpZXMubWFwKChlbnRyeSkgPT4gZW50cnkudW5pdmVyc2l0eSkpLnNpemU7XHJcbiAgY29uc3Qgc29sdmVSYXRlID0gZW50cmllcy5sZW5ndGggPT09IDAgPyAwIDogTWF0aC5taW4oMTAwLCBNYXRoLnJvdW5kKCh0b3RhbFNvbHZlcyAvIChlbnRyaWVzLmxlbmd0aCAqIDEwKSkgKiAxMDApKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGxpdmVQYXJ0aWNpcGFudHM6IGVudHJpZXMubGVuZ3RoLFxyXG4gICAgdW5pdmVyc2l0aWVzLFxyXG4gICAgc3VibWlzc2lvbnM6IHRvdGFsU29sdmVzLFxyXG4gICAgc29sdmVSYXRlOiBOdW1iZXIuaXNGaW5pdGUoc29sdmVSYXRlKSA/IHNvbHZlUmF0ZSA6IDAsXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU3BvdGxpZ2h0RnJvbUVudHJpZXMoZW50cmllczogU3RhbmRpbmdFbnRyeVtdKTogU3RhbmRpbmdzUGF5bG9hZFtcInNwb3RsaWdodFwiXSB7XHJcbiAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBmYXN0ZXN0U29sdmVUZWFtOiBcIlwiLFxyXG4gICAgICBoaWdobGlnaHRNZXNzYWdlOiBcIkF3YWl0aW5nIGxpdmUgc3RhbmRpbmdzLi4uXCIsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbGF0ZXN0U29sdmUgPSBlbnRyaWVzLnJlZHVjZSgobGF0ZXN0LCBlbnRyeSkgPT4ge1xyXG4gICAgaWYgKCFlbnRyeS5sYXN0U3VibWlzc2lvbikge1xyXG4gICAgICByZXR1cm4gbGF0ZXN0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghbGF0ZXN0Lmxhc3RTdWJtaXNzaW9uKSB7XHJcbiAgICAgIHJldHVybiBlbnRyeTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gRGF0ZS5wYXJzZShlbnRyeS5sYXN0U3VibWlzc2lvbikgPiBEYXRlLnBhcnNlKGxhdGVzdC5sYXN0U3VibWlzc2lvbikgPyBlbnRyeSA6IGxhdGVzdDtcclxuICB9LCBlbnRyaWVzWzBdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGZhc3Rlc3RTb2x2ZVRlYW06IGxhdGVzdFNvbHZlLnRlYW0sXHJcbiAgICBoaWdobGlnaHRNZXNzYWdlOiBsYXRlc3RTb2x2ZS5sYXN0U3VibWlzc2lvblxyXG4gICAgICA/IGBMYXRlc3Qgc29sdmUgc3luY2VkIGF0ICR7bmV3IERhdGUobGF0ZXN0U29sdmUubGFzdFN1Ym1pc3Npb24pLnRvTG9jYWxlVGltZVN0cmluZygpfWBcclxuICAgICAgOiBcIlNvbHZlcyBzdHJlYW1pbmcgaW4uLi5cIixcclxuICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRVbml2ZXJzaXR5TWF0cml4KGVudHJpZXM6IFN0YW5kaW5nRW50cnlbXSkge1xyXG4gIHJldHVybiBlbnRyaWVzLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCB7IHRlYW1zOiBudW1iZXI7IGN1bXVsYXRpdmVTY29yZTogbnVtYmVyIH0+PihcclxuICAgIChhY2MsIGVudHJ5KSA9PiB7XHJcbiAgICAgIGlmICghYWNjW2VudHJ5LnVuaXZlcnNpdHldKSB7XHJcbiAgICAgICAgYWNjW2VudHJ5LnVuaXZlcnNpdHldID0geyB0ZWFtczogMCwgY3VtdWxhdGl2ZVNjb3JlOiAwIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFjY1tlbnRyeS51bml2ZXJzaXR5XS50ZWFtcyArPSAxO1xyXG4gICAgICBhY2NbZW50cnkudW5pdmVyc2l0eV0uY3VtdWxhdGl2ZVNjb3JlICs9IGVudHJ5LnNjb3JlO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSxcclxuICAgIHt9XHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN1bW1hcml6ZVN0cmVha3MoZW50cmllczogU3RhbmRpbmdFbnRyeVtdKSB7XHJcbiAgcmV0dXJuIGVudHJpZXMucmVkdWNlKFxyXG4gICAgKGFjYywgZW50cnkpID0+IHtcclxuICAgICAgaWYgKGVudHJ5LnN0cmVhayA+IGFjYy5sb25nZXN0KSB7XHJcbiAgICAgICAgYWNjLmxvbmdlc3QgPSBlbnRyeS5zdHJlYWs7XHJcbiAgICAgICAgYWNjLnRlYW0gPSBlbnRyeS50ZWFtO1xyXG4gICAgICB9XHJcbiAgICAgIGFjYy50b3RhbCArPSBlbnRyeS5zdHJlYWs7XHJcbiAgICAgIHJldHVybiBhY2M7XHJcbiAgICB9LFxyXG4gICAgeyBsb25nZXN0OiAwLCB0b3RhbDogMCwgdGVhbTogXCJcIiB9XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiTUFYX1ZJU0lCTEVfVEVBTVMiLCJub3JtYWxpemVCYWNrZW5kUGF5bG9hZCIsInBheWxvYWQiLCJzdWNjZXNzIiwiZGF0YSIsInVwZGF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInN1bW1hcnkiLCJidWlsZFN1bW1hcnlGcm9tRW50cmllcyIsInNwb3RsaWdodCIsImJ1aWxkU3BvdGxpZ2h0RnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiT2JqZWN0IiwidmFsdWVzIiwibWFwIiwibWFwQmFja2VuZFRlYW1Ub0VudHJ5Iiwic29ydCIsImEiLCJiIiwic2NvcmUiLCJsYXN0U3VibWlzc2lvbiIsImxvY2FsZUNvbXBhcmUiLCJzbGljZSIsImVudHJ5IiwiaW5kZXgiLCJyYW5rIiwidGVhbSIsInNvcnRlZFNvbHZlcyIsInNvbHZlcyIsInBhcnNlIiwiZGF0ZSIsInNvbHZlZCIsImxlbmd0aCIsIm5hbWUiLCJ1bml2ZXJzaXR5IiwiYnJhY2tldF9uYW1lIiwiYWNjb3VudFVybCIsImFjY291bnRfdXJsIiwicGVuYWx0eSIsIk1hdGgiLCJtYXgiLCJzdHJlYWsiLCJ0b3RhbFNvbHZlcyIsInJlZHVjZSIsImFjYyIsInVuaXZlcnNpdGllcyIsIlNldCIsInNpemUiLCJzb2x2ZVJhdGUiLCJtaW4iLCJyb3VuZCIsImxpdmVQYXJ0aWNpcGFudHMiLCJzdWJtaXNzaW9ucyIsIk51bWJlciIsImlzRmluaXRlIiwiZmFzdGVzdFNvbHZlVGVhbSIsImhpZ2hsaWdodE1lc3NhZ2UiLCJsYXRlc3RTb2x2ZSIsImxhdGVzdCIsInRvTG9jYWxlVGltZVN0cmluZyIsImJ1aWxkVW5pdmVyc2l0eU1hdHJpeCIsInRlYW1zIiwiY3VtdWxhdGl2ZVNjb3JlIiwic3VtbWFyaXplU3RyZWFrcyIsImxvbmdlc3QiLCJ0b3RhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/standings.ts\n"));

/***/ })

});